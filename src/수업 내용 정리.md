# Java 기초 프로그래밍 
<hr/>
 
## Index
<hr/>
1. 자바 설치 및 IDE 설치와 사용  
 
- 프로그래밍이란?
 - 주석, 실행문
 - JDK, JRE, JVM
2. 변수
  - 변수 선언, 변수 초기화(Intialize)
  - 변수 사용, 변수 사용범위(Scope)
3. 타입
  - 정수 타입: int, long
  - 실수 타입: double
  - 논리 타입: boolean
4. 타입 변환
  - 자동 타입 변환(Promotion): 작은 범위 -> 큰 범위
  - 강제 타입 변환(Casting): 큰 범위 -> 작은 범위 (캐스팅 연산자)
5. 연산자
  - 단항 연산자, 이항 연산자, 삼항 연산자
  - 산술 연산자, 대입 연산자, 증감 연산자 등
  - 연산자 우선순위가 존재: (), ..... =
6. 조건문
  - if
  - if-else, if-else-if
  - switch-case
7. 반복문
  - while
  - for
  - do-while
  - break, continue
8. 배열
  - 배열 선언, 배열 초기화, 배열 길이
  - 다차원 배열
  - 향상된 for문
9. 메서드
  - 메서드 선언, 메서드 호출,
  - 리턴값, 리턴 타입
  - 매개변수(parameter), 인자(argument)
  - 메서드 오버로딩(overloading)
10. 클래스
  - **객체지향 프로그래밍**
  - 필드, 생성자, 메서드
  - 패키지, 접근 제어자
  - static, 인스턴스 멤버와 정적 멤버
  - final, 싱글톤
  - 캡슐화, 상속, 다형성, 추상화



## 메서드 정의
<hr/>
- 제어자(Modifier) : public, static
- 리턴타입(Return Type): 메서드가 실행된 뒤 반환되는 타입
- 메서드 이름(Method Name): 메서드를 호출하는데 사용됨, 기능이 드러나도록 이름을 짓는 것이 좋다. 
- 매개변수(Parameter): 입력 값, 메서드 내부에서 사용 가능한 변수, 매개변수가 없을 수도 있음.
- 메서드 본문(Method Body): 실행되는 코드 블륵, {} 사이 위치

## 메서드의 종류
<hr/>
- 매개변수가 없고 리턴타입도 없는 메서드 정의 <br/>
- 리턴 타입이 없는 경우 void를 사용

## 메서드의 장점
<hr/>
1. 반복되는 코드의 중복을 줄일 수 있다. 
2. 작업이 분리되어 코드의 가독성이 향상된다. 
3. 코드를 다른 프로그램에서 재사용할 수 있다. 
4. 기존의 기능을 확장해서 사용하는데 유용하다. 
5. 메서드를 사용할 때 내부 작업, 구현부에 대해 알 필요가 없이 사용할 수 있다. 
6. 모듈화된 메서드는 개별적으로 테스트하고 디버깅할 수 있다. 
7. 유지보수가 용이해진다. 

## 메서드 명명 규칙
<hr/>

- 기본적으로 변수의 이름을 붙이는 방식과 같다. (CamelCase 등)
- 메서드의 이름에는 동사를 사용해서 시작하는 것이 좋다. 
    - addNumbers: 두 숫자를 더하는 메서드 <- 명시적으로 추측 가능하도록
    - getStudentInfo: 학생의 정보를 가져오는 메서드
    - setEmployeeName: 직원의 이름을 설정하는 메서드
- 일반적으로 널리 사용되지 않는 약어는 사용하지 않는 것이 좋다. 
    - addN, getSi, setEn <- 무슨 동작을 하는 메서드인지 추측하기 어렵다. 

## 객체지향 프로그래밍
<hr/>

- 절차적 프로그래밍(Procedural Programming)  
  - 프로그램을 일련의 순서, 절차나, 함수의 집합으로 보는 방식
  - 상단에서부터 하단으로 프로그램 코드를 순서대로 실행
  - 함수(Function)/절자(Procedure)를 정의하고 호출
- 객체지향 
  



- 객체(Object)와 인스턴스(instance)의 차이
  - 클래스에서 나온 실체. 인스턴스는 클래스의 관계에 맞춰져있음. 
    - Student는 클래스다. 
    - student1은 Student의 인스턴스다.
    - student1은 객체다. 

## 자바의 메모리 영역 구조
1. 스택(stack) 영역
   - 자바를 실행하면, 각 스레드에 의해 실행 스택이 생성되고, 
   - 메서드가 호출될 때마다 메서드를 위한 스택 프레임이 생성된다. 
   - 스택 프레임에서는 변수 등이 선언되고 메서드 종료시 제거된다. 
2. 힙(heap) 영역
   - 모든 객체와 배열이 생성되고 동적으로 할당되는 영역
   - 모든 스레드에서 공유가 된다. 
   - 더이상 참조가 되지 않는 객체는 GC(Garbage Collector)에 의해 제거된다. 
3. 메서드(Method) 영역
    - 프로그램을 실행하는데 필요한 공통 데이터를 공유하는 영역
    - 모든 스레드에 공유되고, 한 번 불러 온 클래스 정보는 이 영역에 저장됨. 
    - 클래스의 정보, 메서드의 실행 코드, static 영역, 상수 등을 보관 

### Stack 자료구조와 Queue 자료구조
1. Stack 자료구조
   - 후입선출(LIFO: Last In First Out) 방식으로 작동
   - 마지막에 들어간 데이터가 먼저 나온다.   
     ex) 프링글스 통, 입구가 좁은 냉장고 칸
   - 활용 
      - 웹브라우저의 뒤로가기 / 앞으로 가기  
      - 실행취소(Ctrl+z): 실행취소  
      - 자바의 스택 영역
   - 일반적으로 데이터 입력을 push, 출력을 pop이라고 한다. 
   - 데이터 삽입 예시
      - 1 (push) -> 2 (push) -> 3(push) -> 3 (pop) -> 2 (pop) -> 1 (pop)
2. Queue 자료구조
   - 선입선출(FIFO: First In First Out) 방식으로 작동
   - 먼저 들어온 데이터가 먼저 나온다: 식당에서 대기줄을 설 때
   - 활용
     - 프린터 풀력 대기 큐
   - 데이터 삽입 예시
     - 1(push) -> 2(push) -> 3 (push) -> 1(pop) -> 2(pop) -> 3(pop)

## 변수의 종류
1. 인스턴스 변수
   - 클래스 내부에서 선언
   - 객체마다 독립적으로 존재하는 변수 (힙 영역에 매번 새로 만들어짐 => 독립적 객체)
   - `static`이 붙지 않은 변수
   - 더이상 참조하는 변수가 없을 경우 GC이 제거 (객체 소멸 시 함께 제거됨)
   - 객체의 상태를 저장하는데 사용
2. 클래스 변수
   - 클래스 내부에서 선언
   - 모든 객체에서 공유되는 변수 (메서드 영역에 저장)
   - `static`이 붙는 변수
   - 프로그램이 종료될 시 제거
   - 클래스의 공통적인 정보를 저장하는데 사용
3. 지역 변수
   - 메서드 내에서 지역적으로 사용되는 변수
   - 메서드가 종료(스택 프레임이 제거)되면서 제거
   - 매개변수(Parameter)도 동일한 생명주기를 갖는다.
   - 메서드와 관련된 임시적인 값을 저장할 때 사용
- 생명주기 길이 순서
  - 클래스 변수 > 인스턴스 영역 > 지역 변수

## static 키워드
- static 변수
  - 해당 클래스의 모든 인스턴스에서 공유되는 변수
  - 같은 클래스의 모든 객체는 같은 값을 갖게 됨. 
  - 메서드 영역에 할당
  - 메모리 사용량을 줄여서 효율성을 높일 수 있음
  - 객체 생성 없이 사용할 수 있음. 
- static 메서드 
  - 객체 생서 없이 호출할 수 있음.
  - static 메서드에서는 static 변수와, static 메서드만 접근 가능
  - 주로 유틸리성 함수를 작성하는데 사용된다. 
- static 키워드의 장점과 주의점
  - 장점: 메모리 사용 효율화, 코드 간결성
  - 주의점: 캡슐화를 약화시킬 수 있음, 코드 이해가 어려울 수 있음

## 상속(Inheritance)
- 객체지향의 핵심 개념 중 하나
- 한 클래스가 다른 클래스의 필드와 메서드를 이어받아 사용할 수 있음
- 코드의 재사용성을 높이고, 중복을 줄이고, 구조를 체계적으로 관리할 수 있음


- 부모 클래스(Super Class): 상속을 통해 다른 클래스에 필드와 메서드를 제공
- 자식 클래스(Sub Class): 부모 클래스부터 필드와 메서드를 상속받은 클래스


- "is a" 관계를 모델링한다.
  - Dog is a animal. ( animal: 부모 / dog: 자식 )
  - HydroCar is a Car.( car: 부모 / HydroCar: 자식)
- 자바에서 상속 대상은 하나만 선택할 수 있다. (부모 클래스는 하나만)
- 다중 상속은 다이아몬드 문제가 발생할 수 있어 다중상속을 허용하지 않음.
- 자식 클래스는 부모 클래스를 알지만, 부모 클래스는 자식 클래스를 모른다. 


- 상속 관계의 메모리 구조
  - 상관 관계의 객체를 생성하면 부모와 자식이 모두 생성된다. 
  - 상속 관계 객체를 호출할 때, 호출자의 타입을 통해 타입을 찾는다.
  - 대상 타입에서 메서드를 찾지 못할 때, 부모 타입의 메서드를 찾아 실행한다. 


- 메서드 오버라이딩
  - 상속을 통해 얻은 메서드를 자식 클래스에서 재정의 하는 것. 
  - 상속받은 메서드의 구현부를 변경할 수 있다. 
- 오버라이딩 조건
  - 메서드 이름이 같아야 한다. 
  - 매개변수가 같아야 한다. 
  - 접근제어자가 부모보다 같거나 넓어야 한다. 
- @Override 애노테이션을 사용한다. 


- 메서드 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이
  - 오버로딩: 같은 이름의 `메서드를 여러개 정의` 하는 것.
  - 오버라이딩: 하위 클래스에서 상위 클래스 `메서드를 재정의`하는 것. 

  